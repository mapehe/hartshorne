import Mathlib.Topology.Basic
import Mathlib.RingTheory.Ideal.Basic
import Mathlib.FieldTheory.RatFunc.Defs
import Mathlib.RingTheory.Polynomial.Basic
import Mathlib.Algebra.MvPolynomial.CommRing

noncomputable section

variable {ι : Sort*} {κ : ι → Sort*}

namespace Poly

-- Denote polynomials over `k` in `n` variables as `k[n]`.
scoped notation k "[" n "]" => MvPolynomial (Fin n) k
scoped notation k "(" n ")" => FractionRing (MvPolynomial (Fin n) k)

end Poly


open Set Poly

-- Helper definition: Define the product of polynomial sets as a product of the elements.
instance {k : Type*} [Field k] {n : ℕ+} : Mul (Set (k[n])) where
  mul S T := { h : k[n] | ∃ (f : S) (g : T), (f : k[n]) * (g : k[n]) = h }

namespace Set

-- The `zero_locus` of a set in `k[n]` is the set of common
-- zeroes.
@[simp]
def zeroLocus {n : ℕ+} {k : Type*} [Field k]
    (S : Set (k[n])) : Set (Fin n → k) :=
  { P | ∀ f ∈ S, f.eval P = 0 }

-- The ideal of a set in the affine space `k^n` is the set
-- of polynomials that are zero in that set..
@[simp]
def ideal {n : ℕ+} {k : Type*} [Field k]
    (S : Set (Fin n → k)) : Set (k[n]) :=
  {f | ∀ (P : S) ,f.eval P = 0}

end Set

-- The ideal generated by a set is an ideal in the polynomial ring.
def ideal_is_ideal {n : ℕ+} {k : Type*} [Field k]
  (S : Set (Fin n → k)) : Ideal (k[n]) :=
{ carrier := S.ideal,
  zero_mem' := by
    simp only [ideal, Subtype.forall, mem_setOf_eq, map_zero, implies_true],
  add_mem' := by
    intros a b ha hb P
    simp only [ideal, Subtype.forall, mem_setOf_eq, map_add] at *
    specialize ha P.1 P.2
    specialize hb P.1 P.2
    rw [ha, hb]
    simp only [add_zero],
  smul_mem' := by
    intros f g hgP
    simp only [ideal, Subtype.forall, smul_eq_mul, mem_setOf_eq, map_mul, mul_eq_zero]
    simp only [ideal, Subtype.forall, mem_setOf_eq] at hgP
    intro P hP
    specialize hgP P hP
    simp [hgP]}

-- If `S ⊆ T`, then `S.zeroLocus ⊇ T.zeroLocus`.
lemma zero_locus_subset {k : Type*} [Field k] {n : ℕ+}
    {S T : Set (k[n])} (hST : S ⊆ T) :
    S.zeroLocus ⊇ T.zeroLocus := by
  simp only [zeroLocus, setOf_subset_setOf]
  exact fun P hP f hf ↦ let_fun hfT := hST hf;
    hP f hfT

-- The zero-locus of the ideal generated by a finite set of polynomials
-- is exactly the zero-locus of those polynomials themselves.
lemma zeroLocus_ideal_eq_zeroLocus_generators {k : Type*}
    [Field k] {n : ℕ+} {F : Finset (k[n])} :
    ((Ideal.span (F : Set (k[n]))) : Set (k[n])).zeroLocus =
      (F : Set (k[n])).zeroLocus := by
  apply eq_of_subset_of_subset
  · -- `⊆` : a point annihilating the span annihilates the generators.
    exact
      (let_fun hF := Ideal.subset_span;
       zero_locus_subset hF)
  · -- `⊇` : a point annihilating each generator annihilates the span.
    intro P hP
    let A := ideal_is_ideal {P}
    have ha : (F : Set (k[n])) ⊆ A := by
      simp only [zeroLocus, Finset.mem_coe, mem_setOf_eq] at hP
      intro f hf
      specialize hP f hf
      simp [A, ideal_is_ideal]
      exact hP
    have ha2 : (Ideal.span (F : Set (k[n])) : Set (k[n])) ⊆ A :=
      by
        simpa using (Ideal.span_le.2 ha)
    have ha3 : P ∈ (A : Set (k[n])).zeroLocus := by
      simp [A, ideal_is_ideal]
    have h := zero_locus_subset ha2
    exact h ha3

-- If `f ∈ T₁` and `g ∈ T₂`, then `f * g ∈ T₁ * T₂`.
lemma mul_mem_mul {k : Type*} [Field k] {n : ℕ+}
    {f g : k[n]} {T₁ T₂ : Set (k[n])}
    (hf : f ∈ T₁) (hg : g ∈ T₂) :
    f * g ∈ T₁ * T₂ := by use ⟨f, hf⟩, ⟨g, hg⟩


-- If `g P = 0` and `f = g * h`, then `f P = 0`.
lemma eval_mul_left_eq_zero_of_eval_eq_zero {k : Type*} [Field k] {n : ℕ+}
    {f g h : k[n]} {P : Fin n → k}
    (hf : f = g * h) (hz : g.eval P = 0) :
    f.eval P = 0 := by
  simp_rw [hf, map_mul, mul_eq_zero]
  exact Or.inl hz

theorem zero_set_union_eq_zero_set_mul {k : Type*} [Field k] {n : ℕ+}
    {T₁ T₂ : Set (k[n])} :
    T₁.zeroLocus ∪ T₂.zeroLocus = (T₁ * T₂).zeroLocus := by
  apply eq_of_subset_of_subset

  -- ⊆ direction
  intro P hP
  simp only [Set.zeroLocus, mem_setOf_eq] at *
  intro f hf
  obtain ⟨⟨g, hg⟩, ⟨h, hh⟩, rfl⟩ := hf
  rcases hP with hT₁ | hT₂
  · exact eval_mul_left_eq_zero_of_eval_eq_zero rfl (hT₁ g hg)
  · rw [mul_comm]
    exact eval_mul_left_eq_zero_of_eval_eq_zero rfl (hT₂ h hh)

  -- ⊇ direction
  intro P hP
  simp only [Set.zeroLocus, mem_setOf_eq, mem_union]
  by_cases h : P ∈ T₁.zeroLocus
  · exact Or.inl h
  · simp only [Set.zeroLocus, mem_setOf_eq, not_forall, Classical.not_imp] at h
    obtain ⟨g, hg, hgP⟩ := h
    right
    intro f hf
    specialize hP (g * f) (mul_mem_mul hg hf)
    simp only [map_mul, mul_eq_zero, hgP, false_or] at hP
    exact hP

-- The intersection of zero sets of `Tᵢ` is the zero set of the union of `Tᵢ`.
theorem zero_set_iInter_eq_iUnion_zero_set {k : Type*} [Field k] {n : ℕ+}
    {ι : Type*} (s : ι → Set (k[n])) :
    (⋂ i, (s i).zeroLocus) = (⋃ i, s i).zeroLocus := by
  ext P
  simp only [Set.zeroLocus, mem_iInter, mem_iUnion,
    mem_setOf_eq, Subtype.forall, forall_exists_index]

  apply Iff.intro
  · -- (→) direction
    intro h f i hi
    exact h i f hi

  · -- (←) direction
    intro h i f hi
    exact h f i hi

-- Define the Zariski open sets as the complements of algebraic sets.
def ZariskiOpen {k : Type*} [Field k] {n : ℕ+} (U : Set (Fin n → k)) : Prop :=
  ∃ (T : Set (k[n])), U = (T.zeroLocus)ᶜ

-- The whole set is a Zariski open set.
lemma ZariskiOpen.univ {k : Type*} [Field k] {n : ℕ+} :
    ZariskiOpen (Set.univ : Set (Fin n → k)) := by
  simp only [ZariskiOpen, Set.zeroLocus, compl_iInter]
  use {1}
  simp only [Set.zeroLocus, CoeTC.coe, mem_singleton_iff,
    forall_eq, map_one, one_ne_zero, setOf_false, compl_empty]

-- The intersection of two Zariski open sets is Zariski open.
lemma ZariskiOpen.inter {k : Type*} [Field k] {n : ℕ+}
    (U V : Set (Fin n → k)) (hu : ZariskiOpen U) (hv : ZariskiOpen V) :
    ZariskiOpen (U ∩ V) := by
  obtain ⟨T₁, hT₁⟩ := hu
  obtain ⟨T₂, hT₂⟩ := hv
  use T₁ * T₂
  rw [hT₁, hT₂, ←compl_union, compl_inj_iff]
  exact zero_set_union_eq_zero_set_mul

-- Any union of Zariski open sets is Zariski open.
lemma ZariskiOpen.sUnion {k : Type*} [Field k] {n : ℕ+}
    (S : Set (Set (Fin n → k))) (hS : ∀ U ∈ S, ZariskiOpen U) :
    ZariskiOpen (⋃₀ S) := by
  choose T hT using hS
  use ⋃ U : {U // U ∈ S}, T U.1 U.2
  rw [←zero_set_iInter_eq_iUnion_zero_set, compl_iInter, sUnion_eq_iUnion, iUnion_congr]
  intro U
  exact hT U.1 U.2

-- Define the Zariski topology on affine `n`-space.
def ZariskiTopology (k : Type*) [Field k] (n : ℕ+) : TopologicalSpace (Fin n → k) :=
{
  IsOpen := ZariskiOpen,
  isOpen_univ := ZariskiOpen.univ,
  isOpen_inter := ZariskiOpen.inter,
  isOpen_sUnion := ZariskiOpen.sUnion
}

